/** Towers of Hanoi Problem WITHOUT recursion
 *  TOHanoi.cpp
 *     
 *  Fall, 2011
 *
 *  Problem: Towers of Hanoi
 *          You are given three towers a, b, and c. We start with n rings on tower a
 *			and we need to transfer them to tower b subject to the following
 *			restrictions:
 *			1. We can only move one ring at a time, and
 *			2. We may never put a larger numbered ring on top of a smaller numbered
 *			one.
 *			There are always 3 towers. Your program will prompt the user for the
 *			number of rings.
 *
 *  For More Description of TOH Problem:
 *     Check File: 'problem statement for non recursive tower of hanoi.pdf'
 *      
 *  Input: 
 *     Enter the number of rings you want to move:
 *
 *  OutPut Format:
 *     Set of Autogenerated Instructions produced by the program by using non recursive algorithm to 
 *     transfer rings from one tower to the other two towers
 *
 * @param t To represent three towers
 * @param n number of rings
 * @Compiler version on which Program is Last Run before uploading to Github: Dev-C++ 5.4.1, Date: 1st July, 2013   
 * @author Gurpreet Singh
 */
//
//non-recursive function----Towers of Hanoi Problem without recursion
#include<iostream>
#include <cstdlib>
#include<vector>
// NOTE: This program uses the vector container from the stl. 
using namespace std;
int main(){
          vector<int> t[3]; // three towers A,B,C represented as an array of 3 vectors
          int n, candidate,to, from, move=0; // move counts the move number
          cout<<"Please enter any number of rings to move: ";
          cin>>n;
          cout<<endl;
          //intitialize the 3 towers
          for(int k=n+1;k>=1;k--)
                  t[0].push_back(k);
          t[1].push_back(n+1);
          t[2].push_back(n+1);
          // initialize towers and candidate
          
          if(n%2==0)
          {
             from=0 ;
             to=2 ;
             candidate=1 ;          
          }
          else
          {
            from=0;
            to=1;
            candidate=1;
          }
          //t[0].pop_back();
          
          //cout<<"Vector no.:  "<<t[0].at(3);
          
         while( t[1].size()<n+1){ // there are still rings to transfer to tower B = t[1]
                      //write it
    cout<<"move number "<<++move<<": Transfer ring "<<candidate<<" from tower "<<  char(from+65)<<" to tower "<<char(to+65)<<endl;
                      //do it: move the disks around
                     // 1. Push the top of the “from” tower to the “to” tower
                      //2. Remove the ring from the “from” tower
                      t[from].pop_back();
                      t[to].push_back(candidate);
                      //get next “from tower” It’s not the most recent “to” – so which is it?
                      int A1, A2, x[5]={2,0,1,2,0}; 
                      for(int i=1;i<4;i++)
                      {  if(to==x[i])
                           {  A1= x[i-1];
                              A2= x[i+1];        
                           }
                      }// To find A1 and A2 and hence "from"
                      
                      if(t[A1].back() < t[A2].back() )
                          from=A1;
                      else
                          from=A2;
                      // get next “to tower”            
                    for(int i=1;i<4;i++)
                      {  if(n%2!=0){
                            if(from==x[i])
                            {    if(t[from].back() < t[x[i+1]].back()  )     
                                 to=x[i+1]   ;
                              else
                                 to= x[i-1]   ;
                                          
                            }
                           }// outer if loop (n%2!=0) 
                           else {
                           if(from==x[i])
                           {  if(t[from].back() < t[x[i-1]].back()  )     
                                 to=x[i-1]   ;
                              else
                                 to= x[i+1]   ;
                                          
                            }     
                         }//Main outer else ends her
                      }//To find "to"
       
                  //get next candidate
                  candidate= t[from].back() ; // it’s on the top of the current “from tower”
              }
          
          system("pause");
          return 0;
}
